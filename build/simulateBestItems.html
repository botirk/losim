<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>simulateBestItems.html</title>
    <script defer="">// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5keNS":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "b6dc7ccb1a6304f0";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"fvuCG":[function(require,module,exports) {
var _simulateBestItemsTs = require("./simulateBestItems.ts");

},{"./simulateBestItems.ts":"cagS6"}],"cagS6":[function(require,module,exports) {
var _champions = require("../champions/champions");
var _simulateBestItems = require("../simulation/simulateBestItems");
var _masterYi = require("../champions/MasterYi/MasterYi");
var process = require("120ca68fe6f93026");
const getSetupNode = async ()=>{
    {
        const rli = require("cd537028ec2c6585").createInterface(process.stdin, process.stdout);
        for(const i in 0, _champions.champions)rli.write(`${i} ${new (0, _champions.champions)[i]().name}\n`);
        const champName = await rli.question("Pick a champion (number or string) Master Yi default\n");
        const Champion = (0, _champions.champions)[champName] || (0, _champions.champions).find((champ)=>new champ().name.toLowerCase() === champName.toLowerCase()) || (0, _masterYi.MasterYi);
        let itemsCount = parseInt(await rli.question("Count of items (1-6) 1 default\n"));
        if (isNaN(itemsCount)) itemsCount = 1;
        itemsCount = Math.max(1, Math.min(6, Math.floor(itemsCount)));
        let level = parseInt(await rli.question("Select champion level (1-18) 9 default\n"));
        if (isNaN(level)) level = 9;
        level = Math.max(1, Math.min(18, Math.floor(level)));
        const shouldRunAway = (await rli.question("Should dummy run away (y/n) n default\n"))[0] === "y" ? true : false;
        rli.close();
        return {
            level,
            shouldRunAway,
            Champion,
            itemsCount,
            withBoots: false
        };
    }
};
const getSetupBrowser = async ()=>{
    await new Promise((res)=>setTimeout(res, 250));
    let champNames = (0, _champions.champions).reduce((prev, cur, i)=>prev + `${i} ${new cur().name}\n`, "");
    const champName = prompt(champNames + "Pick a champion (number or string) Master Yi default");
    const Champion = (0, _champions.champions)[champName] || (0, _champions.champions).find((champ)=>new champ().name.toLowerCase() === champName.toLowerCase()) || (0, _masterYi.MasterYi);
    let itemsCount = parseInt(prompt("Count of items (1-6) 1 default\n"));
    if (isNaN(itemsCount)) itemsCount = 1;
    itemsCount = Math.max(1, Math.min(6, Math.floor(itemsCount)));
    let level = parseInt(prompt("Select champion level (1-18) 9 default\n"));
    if (isNaN(level)) level = 9;
    level = Math.max(1, Math.min(18, Math.floor(level)));
    const shouldRunAway = prompt("Should dummy run away (y/n) n default\n")[0] === "y" ? true : false;
    return {
        level,
        shouldRunAway,
        Champion,
        itemsCount,
        withBoots: false
    };
};
const getSetup = async ()=>{
    if (typeof window !== "undefined") return await getSetupBrowser();
    else return await getSetupNode();
};
const writeResult = (str)=>{
    if (typeof window !== "undefined") document.body.innerText = str;
    else console.log(str);
};
(async ()=>{
    const setup = await getSetup();
    const result = await (0, _simulateBestItems.simulateBestNextItems)((sim)=>{
        const champ = new setup.Champion();
        champ.level = setup.level;
        champ.init(sim);
        champ.levelUp();
        return champ;
    }, setup.itemsCount, setup.shouldRunAway);
    let resultStr = "";
    if (result.length > 0) for (const subresult of result){
        for(const itemn in subresult.items)resultStr += `item${Number(itemn) + 1}: '${subresult.items[itemn].name}' `;
        resultStr += `timetokill: ${(subresult.result.ttk / 1000).toFixed(2)} dps: ${subresult.result.dps1.toFixed(2)}\r\n`;
    }
    else resultStr += `Simulation failed, no items simulated\r\n`;
    writeResult(resultStr);
})();

},{"120ca68fe6f93026":"50f2S","../champions/champions":"6LTqv","../simulation/simulateBestItems":"loqvP","../champions/MasterYi/MasterYi":"4UhOt","cd537028ec2c6585":"jhUEF"}],"50f2S":[function(require,module,exports) {
module.exports = {};

},{}],"6LTqv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "champions", ()=>champions);
var _masterYi = require("./MasterYi/MasterYi");
var _nunu = require("./Nunu/Nunu");
const champions = [
    (0, _masterYi.MasterYi),
    (0, _nunu.Nunu)
];

},{"./MasterYi/MasterYi":"4UhOt","./Nunu/Nunu":"2c9S9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4UhOt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiAction", ()=>MasterYiAction);
parcelHelpers.export(exports, "MasterYi", ()=>MasterYi);
var _unit = require("../../unit/unit");
var _champion = require("../champion/champion");
var _masterYiStats = require("./MasterYiStats");
var _masterYiE = require("./MasterYiE");
var _masterYiR = require("./MasterYiR");
var _masterYiW = require("./MasterYiW");
var _masterYiQ = require("./MasterYiQ");
var _masterYiPassive = require("./MasterYiPassive");
class MasterYiAction extends (0, _unit.Actions) {
    init() {
        super.init();
        this.e = new (0, _masterYiE.MasterYiE)(this.owner);
        this.r = new (0, _masterYiR.MasterYiR)(this.owner);
        this.passive = new (0, _masterYiPassive.MasterYiPassive)(this.owner).init();
        this.w = new (0, _masterYiW.MasterYiW)(this.owner);
        this.q = new (0, _masterYiQ.MasterYiQ)(this.owner);
        return this;
    }
}
class MasterYi extends (0, _champion.Champion) {
    constructor(){
        super("Master Yi");
        this.isMelee = true;
        this.stats = (0, _masterYiStats.MasterYiStats);
        this.levelUpPriority = [
            "R",
            "Q",
            "E",
            "W"
        ];
    }
    levelUp() {
        this.levelUpAnyChampion(this.action.q, this.action.w, this.action.e, this.action.r);
    }
    async killDummy(enemy) {
        if (this.distance(enemy) > this.action.attack.maxRange && await this.action.q.cast(enemy)) return;
        else if (await this.action.r.cast()) return;
        else if (this.action.attack.currentCast && await this.action.attack.currentCast.wait()) return;
        else if (this.action.attack.isCooldown && await this.action.move.closeTo(enemy)) return;
        else if (this.action.attack.castable(enemy) && await this.action.e.cast()) return;
        else if (await this.action.attack.cast(enemy)) return;
        else await this.action.move.closeTo(enemy);
    }
    init(simIN) {
        super.init(simIN);
        this.action = new MasterYiAction(this);
        this.action.init();
        return this;
    }
}

},{"../../unit/unit":"hwZ7t","../champion/champion":"8r64O","./MasterYiStats":"kRNkn","./MasterYiE":"RltaG","./MasterYiR":"9XjdV","./MasterYiW":"9PlHv","./MasterYiQ":"8SIbV","./MasterYiPassive":"aPd16","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwZ7t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Actions", ()=>Actions);
parcelHelpers.export(exports, "Unit", ()=>Unit);
var _watchable = require("../simulation/watchable");
var _unitInteraction = require("./unitInteraction");
var _attack = require("./action/attack");
var _move = require("./action/move");
class Actions {
    constructor(owner){
        this.owner = owner;
    }
    init() {
        this.attack = new (0, _attack.AttackAction)(this.owner);
        this.move = new (0, _move.MoveAction)(this.owner);
        return this;
    }
}
class Targetable extends (0, _watchable.Watchable) {
    constructor(value, unit){
        super(value);
        this.unit = unit;
        this._stacks = 0;
        unit.dead.callback(()=>super.value = this.value);
    }
    get value() {
        return !this.unit.dead.value && this._stacks <= 0;
    }
    set value(value) {
        if (value) this._stacks = Math.max(0, this._stacks - 1);
        else this._stacks += 1;
        super.value = this.value;
    }
}
class CurrentCast extends (0, _watchable.Watchable) {
    constructor(value){
        super(value);
    }
    get value() {
        if (!super.value?.isCasting) return undefined;
        else return super.value;
    }
    set value(value) {
        super.value = value;
    }
}
class Unit {
    constructor(name){
        this.name = name;
        this.level = 1;
        this.health = 0;
        this.maxHealth = 0;
        this.mana = 0;
        this.maxMana = 0;
        this.armor = 0;
        this.mr = 0;
        this.pos = 0;
        this.baseMs = 0;
        this.bonusMs = 0;
        this.// ad
        attackRange = 175;
        this.attackAnimation = 0.4;
        this.baseAd = 0;
        this.bonusAd = 0;
        this.lifesteal = 0;
        this.crit = 0;
        this.bonusCritDamage = 0;
        this.// attack speed related
        baseAs = 0;
        this.bonusAs = new (0, _watchable.Watchable)(0);
        this.// death related
        dead = new (0, _watchable.Watchable)(false);
        this.// targetable related
        targetable = new Targetable(true, this);
        this.// buffs
        buffs = [];
        this._itemCount = 0;
        this.appliedEquips = [];
        this.// cast
        currentCast = new CurrentCast(undefined);
    }
    // move
    distance(unit) {
        return Math.abs(this.pos - unit.pos);
    }
    get ms() {
        return Math.max(110, (this.baseMs + this.bonusMs) * ((100 - this.slow) / 100));
    }
    get slow() {
        return this.buffs.reduce((prev, cur)=>cur.slow > prev ? cur.slow : prev, 0);
    }
    get ad() {
        return this.baseAd + this.bonusAd;
    }
    get as() {
        return this.baseAs * (1 + this.bonusAs.value / 100);
    }
    buffsNamed(name) {
        return this.buffs.filter((buff)=>buff.name === name);
    }
    buffNamed(name) {
        return this.buffs.find((buff)=>buff.name === name);
    }
    get itemCount() {
        return this._itemCount;
    }
    applyEquip(equip) {
        if (equip.unique && this.appliedEquips.includes(equip)) return false;
        if (equip.uniqueGroup && this.appliedEquips.some((e)=>e.uniqueGroup === equip.uniqueGroup)) return false;
        if (equip.type === "item" || equip.type === "finishedItem") {
            if (this._itemCount >= 6) return false;
            this._itemCount += 1;
        }
        if (equip.apply?.(this) === false) return false;
        if (equip.bonusAs) this.bonusAs.value += equip.bonusAs;
        if (equip.bonusAd) this.bonusAd += equip.bonusAd;
        if (equip.crit) this.crit = Math.max(0, Math.min(100, this.crit + equip.crit));
        if (equip.bonusCritDamage) this.bonusCritDamage += equip.bonusCritDamage;
        if (equip.lifesteal) this.lifesteal += equip.lifesteal;
        if (equip.armor) this.armor += equip.armor;
        if (equip.mr) this.mr += equip.mr;
        if (equip.maxHealth) this.maxHealth += equip.maxHealth;
        if (equip.maxMana) this.maxMana += equip.maxMana;
        if (equip.bonusMs) this.bonusMs += equip.bonusMs;
        this.appliedEquips.push(equip);
        return true;
    }
    // logic
    async runAwayFromEnemyAsDummy(enemy) {
        await this.action.move.awayFrom(enemy);
    }
    async killDummy(enemy) {
        if (this.action.attack.currentCast && await this.action.attack.currentCast.wait()) return;
        else if (this.action.attack.isCooldown && await this.action.move.closeTo(enemy)) return;
        else if (await this.action.attack.cast(enemy)) return;
        else await this.action.move.closeTo(enemy);
    }
    init(simIN) {
        if (!this.interaction) this.interaction = new (0, _unitInteraction.UnitInteraction)(this).init();
        if (this.sim) {
            const i = this.sim.units.indexOf(this);
            if (i !== -1) this.sim.units.splice(i, 1);
        }
        this.sim = simIN;
        if (simIN) this.sim.units.push(this);
        this.dead.value = false;
        return this;
    }
}

},{"../simulation/watchable":"EqDFh","./unitInteraction":"ipKmh","./action/attack":"hkICG","./action/move":"2NNAu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"EqDFh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Watchable", ()=>Watchable);
class Watchable {
    constructor(_value){
        this._value = _value;
        this._callbacks = [];
    }
    set value(value) {
        if (this._value === value) return;
        const old = this._value;
        this._value = value;
        for (const listener of this._callbacks)listener(old, value);
    }
    get value() {
        return this._value;
    }
    callback(cb) {
        this._callbacks.push(cb);
        return ()=>{
            const i = this._callbacks.indexOf(cb);
            if (i !== -1) this._callbacks.splice(i, 1);
        };
    }
    promise(stopper, cond) {
        return new Promise((resolve)=>{
            const cancel = this.callback((oldValue, newValue)=>{
                if (cond === undefined || cond === newValue || typeof cond === "function" && cond(oldValue, newValue)) {
                    cancel();
                    resolve([
                        oldValue,
                        newValue
                    ]);
                }
            });
            stopper.then(()=>cancel());
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"ipKmh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DamageType", ()=>DamageType);
parcelHelpers.export(exports, "UnitInteraction", ()=>UnitInteraction);
var DamageType;
(function(DamageType) {
    DamageType[DamageType["TRUE"] = 0] = "TRUE";
    DamageType[DamageType["PHYSIC"] = 1] = "PHYSIC";
    DamageType[DamageType["MAGIC"] = 2] = "MAGIC";
})(DamageType || (DamageType = {}));
class UnitInteraction {
    constructor(unit){
        this.unit = unit;
        this._onTakeDamage = [];
        this._percentDamageReduction = [];
        this._onKill = [];
        this._takedownTimes = new Map();
        this._onTakedown = [];
    }
    takeHeal(e) {
        // prevent beating the dead
        if (this.unit.dead.value === true) return;
        // fix
        e.value = Math.max(0, Math.min(this.unit.maxHealth, e.value));
        // increase health
        this.unit.health += e.value;
    }
    takeDamage(e) {
        // prevent beating the dead
        if (this.unit.dead.value === true) return {
            ...e,
            value: 0
        };
        // percent damage reduction
        for (const listener of this._percentDamageReduction)listener(e);
        // fix
        e.value = Math.max(0, Math.min(this.unit.health, e.value));
        // reduce health
        this.unit.health = Math.max(0, this.unit.health - e.value);
        // events
        for (const listener of this._onTakeDamage)listener(e);
        this._takedownTimes.set(e.src, this.unit.sim.time);
        if (this.unit.health === 0) {
            this.unit.dead.value = true;
            e.src.interaction.kill(this.unit);
            for (const takedownTime of this._takedownTimes){
                takedownTime[0].interaction.takedown(this.unit, takedownTime[1]);
                this._takedownTimes.delete(takedownTime[0]);
            }
        }
        return e;
    }
    onTakeDamage(cb) {
        this._onTakeDamage.push(cb);
        return ()=>{
            const i = this._onTakeDamage.indexOf(cb);
            if (i !== -1) this._onTakeDamage.splice(i, 1);
        };
    }
    percentDamageReduction(cb) {
        this._percentDamageReduction.push(cb);
        return ()=>{
            const i = this._percentDamageReduction.indexOf(cb);
            if (i !== -1) this._percentDamageReduction.splice(i, 1);
        };
    }
    calcPercentDamageReduction(e) {
        for (const listener of this._percentDamageReduction)listener(e);
        return e;
    }
    calcArmorDamageReduction(e) {
        if (e.type === 1) e.value = (1 - this.unit.armor / (100 + this.unit.armor)) * e.value;
        return e;
    }
    calcMrDamageReduction(e) {
        if (e.type === 2) e.value = (1 - this.unit.mr / (100 + this.unit.mr)) * e.value;
        return e;
    }
    onKill(cb) {
        this._onKill.push(cb);
        return ()=>{
            const i = this._onKill.indexOf(cb);
            if (i !== -1) this._onKill.splice(i, 1);
        };
    }
    kill(killed) {
        for (const listener of this._onKill)listener(killed);
    }
    onTakedown(cb) {
        this._onTakedown.push(cb);
        return ()=>{
            const i = this._onTakedown.indexOf(cb);
            if (i !== -1) this._onTakedown.splice(i, 1);
        };
    }
    takedown(takedowned, damagedTime) {
        for (const listener of this._onTakedown)listener(takedowned, damagedTime);
    }
    init() {
        this.percentDamageReduction((e)=>this.calcArmorDamageReduction(e));
        this.percentDamageReduction((e)=>this.calcMrDamageReduction(e));
        return this;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hkICG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AttackAction", ()=>AttackAction);
parcelHelpers.export(exports, "AttackCast", ()=>AttackCast);
var _action = require("./action");
var _unitInteraction = require("../unitInteraction");
var _seedrandom = require("seedrandom");
var _seedrandomDefault = parcelHelpers.interopDefault(_seedrandom);
class AttackAction extends (0, _action.EnemyTargetAction) {
    constructor(owner){
        super("Attack", owner);
        this.minLevel = 0;
        this.maxLevel = 0;
        this.isCancelableByUser = true;
        this.isCooldownFinishedOnInterrupt = true;
        this.isUltimate = false;
        this.random = (0, _seedrandomDefault.default)();
        owner.bonusAs.callback(()=>{
            this.setCooldown(this.cooldownTime);
            if (this.currentCast) this.currentCast.waitFor = this.castTime;
        });
    }
    get maxRange() {
        return this.owner.attackRange;
    }
    get castTime() {
        return 1 / this.owner.as * this.owner.attackAnimation * 1000;
    }
    get cooldownTime() {
        return 1 / this.owner.as * 1000;
    }
    castable(option) {
        return !this.owner.dead.value && option.targetable.value && Math.abs(this.owner.pos - option.pos) < this.maxRange;
    }
    calc(target) {
        return target.interaction.calcPercentDamageReduction({
            value: this.owner.ad,
            src: this.owner,
            type: (0, _unitInteraction.DamageType).PHYSIC
        }).value;
    }
    async cast(option) {
        return await new AttackCast(this, option, this.random).init();
    }
}
class AttackCast extends (0, _action.TargetCast) {
    constructor(action, option, random){
        super(action, option);
        this.random = random;
    }
    async onFinishCast() {
        const isCrit = Math.max(0, Math.min(100, this.action.owner.crit)) >= this.random() * 100;
        const value = isCrit ? this.action.owner.ad * (1.75 + this.action.owner.bonusCritDamage / 100) : this.action.owner.ad;
        this.action.procOnHitUnit(this.option);
        const result = this.option.interaction.takeDamage({
            value,
            src: this.action.owner,
            type: (0, _unitInteraction.DamageType).PHYSIC,
            isCrit
        });
        if (this.action.owner.lifesteal > 0) this.action.owner.interaction.takeHeal({
            src: this.action.owner,
            value: result.value * (this.action.owner.lifesteal / 100)
        });
    }
    async init() {
        if (this.action.currentCast) return this.action.currentCast.wait();
        if (!this.action.castable(this.option)) return false;
        if (this.action.isCooldown) {
            const result = await Promise.any([
                this.action.waitCooldown(),
                this.option.targetable.promise(this.action.waitCooldown(), false).then(()=>false),
                this.action.owner.dead.promise(this.action.waitCooldown(), true).then(()=>false),
                this.action.owner.currentCast.promise(this.action.waitCooldown(), (cast)=>cast !== this).then(()=>false)
            ]);
            if (result === false) return false;
        }
        return await super.init();
    }
}

},{"./action":"InEMf","../unitInteraction":"ipKmh","seedrandom":"kcfU7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"InEMf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Action", ()=>Action);
parcelHelpers.export(exports, "EnemyTargetAction", ()=>EnemyTargetAction);
parcelHelpers.export(exports, "Cast", ()=>Cast);
parcelHelpers.export(exports, "SelfCast", ()=>SelfCast);
parcelHelpers.export(exports, "TargetCast", ()=>TargetCast);
parcelHelpers.export(exports, "PosCast", ()=>PosCast);
class Action {
    constructor(name, owner){
        this.name = name;
        this.owner = owner;
        this._level = 0;
        this._onCast = [];
    }
    // level
    levelUp() {
        if (this.level >= this.maxLevel) return false;
        else if (this.isUltimate) {
            if (this.owner.level < 6) return false;
            else if (this.owner.level < 11 && this.level >= 1) return false;
            else if (this.owner.level < 16 && this.level >= 2) return false;
        } else if (this.level >= Math.ceil(this.owner.level / 2)) return false;
        this.level += 1;
        return true;
    }
    // costs
    get manaCost() {
        return 0;
    }
    get level() {
        return this._level;
    }
    set level(value) {
        this._level = Math.max(0, Math.min(this.maxLevel, value));
    }
    startCooldown() {
        if (!this.isCooldown) this.cooldown = this.owner.sim.waitFor(this.cooldownTime);
    }
    get isCooldown() {
        return !!this.cooldown && this.cooldown.result === undefined;
    }
    async waitCooldown() {
        await this?.cooldown;
    }
    get remainingCooldown() {
        return this.cooldown?.remainingTime || 0;
    }
    set remainingCooldown(value) {
        if (this.cooldown) this.cooldown.remainingTime = value;
    }
    setCooldown(waitFor) {
        if (this.cooldown) this.cooldown.waitFor = waitFor;
    }
    finishCooldown() {
        this.cooldown?.resolve(true);
        this.cooldown = undefined;
    }
    // cast
    castable(option) {
        return this.level >= this.minLevel && (!this.owner.currentCast.value || this.castTime === 0) && !this.isCooldown && !this.owner.dead.value && this.owner.mana >= this.manaCost;
    }
    get currentCast() {
        if (this.owner.currentCast.value?.action === this) return this.owner.currentCast.value;
    }
    onCast(cb) {
        this._onCast.push(cb);
        return ()=>{
            const i = this._onCast.indexOf(cb);
            if (i !== -1) this._onCast.splice(i, 1);
        };
    }
    procOnCast(option) {
        for (const listener of this._onCast)listener(option);
    }
}
class EnemyTargetAction extends Action {
    onHitUnit(cb) {
        this._onHitUnit.push(cb);
        return ()=>{
            const i = this._onHitUnit.indexOf(cb);
            if (i !== -1) this._onHitUnit.splice(i, 1);
        };
    }
    procOnHitUnit(target, multiplier = 1) {
        for (const listener of this._onHitUnit)listener(target, multiplier);
    }
    castable(option) {
        return super.castable(option) && option.targetable.value && Math.abs(option.pos - this.owner.pos) <= this.maxRange;
    }
    constructor(...args){
        super(...args);
        this._onHitUnit = [];
    }
}
class Cast {
    constructor(action, option){
        this.action = action;
        this.option = option;
    }
    get remaining() {
        return this.wheel?.remainingTime || 0;
    }
    set waitFor(waitFor) {
        if (this.wheel) this.wheel.waitFor = waitFor;
    }
    get isCasting() {
        return !!this.wheel && this.wheel.result === undefined;
    }
    async wait() {
        return await this.wheel;
    }
    async interrupt() {
        this.wheel?.resolve(false);
        await this.action.owner.sim.waitFor(0);
    }
    async cancel() {
        if (!this.action.isCancelableByUser) throw new Error(`${this.action.name}'s cast is not cancelable by user`);
        await this.interrupt();
    }
    async watchInterrupt() {}
    async onStartCast() {}
    async onFinishCast() {}
    async init() {
        if (this.action.currentCast) return this.action.currentCast.wait();
        if (!this.action.castable(this.option)) return false;
        this.action.owner.mana -= this.action.manaCost;
        if (this.action.castTime <= 0) {
            this.action.startCooldown();
            this.onStartCast();
            this.onFinishCast();
            return true;
        } else {
            this.wheel = this.action.owner.sim.waitFor(this.action.castTime);
            this.action.owner.currentCast.value = this;
            this.action.startCooldown();
            this.watchInterrupt();
            this.onStartCast();
            const result = await this.wheel;
            if (result) {
                this.onFinishCast();
                this.action.procOnCast(this.option);
            } else if (this.action.isCooldownFinishedOnInterrupt) this.action.finishCooldown();
            return result;
        }
    }
}
class SelfCast extends Cast {
    constructor(...args){
        super(...args);
        this.watchInterrupt = async ()=>{
            const result = await Promise.any([
                this.action.owner.dead.promise(this.wait()).then(()=>false),
                this.wait()
            ]);
            if (result === false) this.interrupt();
        };
    }
}
class TargetCast extends Cast {
    constructor(...args){
        super(...args);
        this.watchInterrupt = async ()=>{
            const result = await Promise.any([
                this.option.targetable.promise(this.wait(), false).then(()=>false),
                this.action.owner.dead.promise(this.wait(), true).then(()=>false),
                this.wait()
            ]);
            if (result === false) this.interrupt();
        };
    }
}
class PosCast extends Cast {
    constructor(...args){
        super(...args);
        this.watchInterrupt = async ()=>{
            const result = await Promise.any([
                this.action.owner.dead.promise(this.wait(), true).then(()=>false),
                this.wait()
            ]);
            if (result === false) this.interrupt();
        };
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcfU7":[function(require,module,exports) {
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.
// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require("12650d0e2f5e5e92");
// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require("2e9ff46cdee4aab4");
// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require("a04af32374227880");
// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require("65d05f6db8da652c");
// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require("1e972c6b140abbe7");
// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require("286eb9753e804cda");
// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require("a0d0bb1ebcf7d3f9");
sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;
module.exports = sr;

},{"12650d0e2f5e5e92":"c47hP","2e9ff46cdee4aab4":"hy9Go","a04af32374227880":"8ktBo","65d05f6db8da652c":"i5aBa","1e972c6b140abbe7":"7tXtZ","286eb9753e804cda":"eVmNr","a0d0bb1ebcf7d3f9":"lbeKh"}],"c47hP":[function(require,module,exports) {
// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
(function(global, module1, define1) {
    function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
            var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
        };
        // Apply the seeding algorithm from Baagoe.
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) me.s0 += 1;
        me.s1 -= mash(seed);
        if (me.s1 < 0) me.s1 += 1;
        me.s2 -= mash(seed);
        if (me.s2 < 0) me.s2 += 1;
        mash = null;
    }
    function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
    }
    function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
            return xg.next() * 0x100000000 | 0;
        };
        prng.double = function() {
            return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
        };
        prng.quick = prng;
        if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    function Mash() {
        var n = 0xefc8249d;
        var mash = function(data) {
            data = String(data);
            for(var i = 0; i < data.length; i++){
                n += data.charCodeAt(i);
                var h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        return mash;
    }
    if (module1 && module1.exports) module1.exports = impl;
    else if (define1 && define1.amd) define1(function() {
        return impl;
    });
    else this.alea = impl;
})(this, module, typeof define == "function" && define // present with an AMD loader
);

},{}],"hy9Go":[function(require,module,exports) {
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        // Set up generator function.
        me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) // Integer seed.
        me.x = seed;
        else // String seed.
        strseed += seed;
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 64; k++){
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
        }
    }
    function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0);
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) module1.exports = impl;
    else if (define1 && define1.amd) define1(function() {
        return impl;
    });
    else this.xor128 = impl;
})(this, module, typeof define == "function" && define // present with an AMD loader
);

},{}],"8ktBo":[function(require,module,exports) {
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this, strseed = "";
        // Set up generator function.
        me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) // Integer seed.
        me.x = seed;
        else // String seed.
        strseed += seed;
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 64; k++){
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) me.d = me.x << 10 ^ me.x >>> 4;
            me.next();
        }
    }
    function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0);
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) module1.exports = impl;
    else if (define1 && define1.amd) define1(function() {
        return impl;
    });
    else this.xorwow = impl;
})(this, module, typeof define == "function" && define // present with an AMD loader
);

},{}],"i5aBa":[function(require,module,exports) {
// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this;
        // Set up generator function.
        me.next = function() {
            // Update xor generator.
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
        };
        function init(me, seed) {
            var j, w, X = [];
            if (seed === (seed | 0)) // Seed state array using a 32-bit integer.
            w = X[0] = seed;
            else {
                // Seed state using a string.
                seed = "" + seed;
                for(j = 0; j < seed.length; ++j)X[j & 7] = X[j & 7] << 15 ^ seed.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
            // Enforce an array length of 8, not all zeroes.
            while(X.length < 8)X.push(0);
            for(j = 0; j < 8 && X[j] === 0; ++j);
            if (j == 8) w = X[7] = -1;
            else w = X[j];
            me.x = X;
            me.i = 0;
            // Discard an initial 256 values.
            for(j = 256; j > 0; --j)me.next();
        }
        init(me, seed);
    }
    function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
    }
    function impl(seed, opts) {
        if (seed == null) seed = +new Date;
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0);
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (state.x) copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) module1.exports = impl;
    else if (define1 && define1.amd) define1(function() {
        return impl;
    });
    else this.xorshift7 = impl;
})(this, module, typeof define == "function" && define // present with an AMD loader
);

},{}],"7tXtZ":[function(require,module,exports) {
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this;
        // Set up generator function.
        me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            // Update Weyl generator.
            me.w = w = w + 0x61c88647 | 0;
            // Update xor generator.
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            // Update Xor generator array state.
            v = X[i] = v ^ t;
            me.i = i;
            // Result is the combination.
            return v + (w ^ w >>> 16) | 0;
        };
        function init(me, seed) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed === (seed | 0)) {
                // Numeric seeds initialize v, which is used to generates X.
                v = seed;
                seed = null;
            } else {
                // String seeds are mixed into v and X one character at a time.
                seed = seed + "\x00";
                v = 0;
                limit = Math.max(limit, seed.length);
            }
            // Initialize circular array and weyl value.
            for(i = 0, j = -32; j < limit; ++j){
                // Put the unicode characters into the array, and shuffle them.
                if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
                // After 32 shuffles, take v as the starting w value.
                if (j === 0) w = v;
                v ^= v << 10;
                v ^= v >>> 15;
                v ^= v << 4;
                v ^= v >>> 13;
                if (j >= 0) {
                    w = w + 0x61c88647 | 0; // Weyl.
                    t = X[j & 127] ^= v + w; // Combine xor and weyl to init array.
                    i = 0 == t ? i + 1 : 0; // Count zeroes.
                }
            }
            // We have detected all zeroes; make the key nonzero.
            if (i >= 128) X[(seed && seed.length || 0) & 127] = -1;
            // Run the generator 512 times to further mix the state before using it.
            // Factoring this as a function slows the main generator, so it is just
            // unrolled here.  The weyl generator is not advanced while warming up.
            i = 127;
            for(j = 512; j > 0; --j){
                v = X[i + 34 & 127];
                t = X[i = i + 1 & 127];
                v ^= v << 13;
                t ^= t << 17;
                v ^= v >>> 15;
                t ^= t >>> 12;
                X[i] = v ^ t;
            }
            // Storing state as object members is faster than using closure variables.
            me.w = w;
            me.X = X;
            me.i = i;
        }
        init(me, seed);
    }
    function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
    }
    function impl(seed, opts) {
        if (seed == null) seed = +new Date;
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0);
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (state.X) copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) module1.exports = impl;
    else if (define1 && define1.amd) define1(function() {
        return impl;
    });
    else this.xor4096 = impl;
})(this, module, typeof define == "function" && define // present with an AMD loader
);

},{}],"eVmNr":[function(require,module,exports) {
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
(function(global, module1, define1) {
    function XorGen(seed) {
        var me = this, strseed = "";
        // Set up generator function.
        me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
        };
        /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */ me.a = 0;
        me.b = 0;
        me.c = -1640531527;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
            // Integer seed.
            me.a = seed / 0x100000000 | 0;
            me.b = seed | 0;
        } else // String seed.
        strseed += seed;
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 20; k++){
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
        }
    }
    function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0);
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module1 && module1.exports) module1.exports = impl;
    else if (define1 && define1.amd) define1(function() {
        return impl;
    });
    else this.tychei = impl;
})(this, module, typeof define == "function" && define // present with an AMD loader
);

},{}],"lbeKh":[function(require,module,exports) {
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/ (function(global, pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //
    var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.
    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
        var key = [];
        options = options == true ? {
            entropy: true
        } : options || {};
        // Flatten the seed string or build one from local entropy if needed.
        var shortseed = mixkey(flatten(options.entropy ? [
            seed,
            tostring(pool)
        ] : seed == null ? autoseed() : seed, 3), key);
        // Use the seed to initialize an ARC4 generator.
        var arc4 = new ARC4(key);
        // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.
        var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0; //   and no 'extra last byte'.
            while(n < significance){
                n = (n + x) * width; //   shifting numerator and
                d *= width; //   denominator and generating a
                x = arc4.g(1); //   new least-significant-byte.
            }
            while(n >= overflow){
                n /= 2; //   last byte, shift everything
                d /= 2; //   right using integer math until
                x >>>= 1; //   we have exactly the desired bits.
            }
            return (n + x) / d; // Form the number within [0, 1).
        };
        prng.int32 = function() {
            return arc4.g(4) | 0;
        };
        prng.quick = function() {
            return arc4.g(4) / 0x100000000;
        };
        prng.double = prng;
        // Mix the randomness into accumulated entropy.
        mixkey(tostring(arc4.S), pool);
        // Calling convention: what to return as a function of prng, seed, is_math.
        return (options.pass || callback || function(prng, seed, is_math_call, state) {
            if (state) {
                // Load the arc4 state from the given state if it has an S array.
                if (state.S) copy(state, arc4);
                // Only provide the .state method if requested via options.state.
                prng.state = function() {
                    return copy(arc4, {});
                };
            }
            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) {
                math[rngname] = prng;
                return seed;
            } else return prng;
        })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
    }
    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        // The empty key [] is treated as [0].
        if (!keylen) key = [
            keylen++
        ];
        // Set up S using the standard key scheduling algorithm.
        while(i < width)s[i] = i++;
        for(i = 0; i < width; i++){
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
        }
        // The "g" method returns the next (count) outputs as one number.
        (me.g = function(count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t, r = 0, i = me.i, j = me.j, s = me.S;
            while(count--){
                t = s[i = mask & i + 1];
                r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
            }
            me.i = i;
            me.j = j;
            return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
        })(width);
    }
    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
            for(prop in obj)try {
                result.push(flatten(obj[prop], depth - 1));
            } catch (e) {}
        }
        return result.length ? result : typ == "string" ? obj : obj + "\x00";
    }
    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while(j < stringseed.length)key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        return tostring(key);
    }
    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
        try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) // The use of 'out' to remember randomBytes makes tight minified code.
            out = out(width);
            else {
                out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
        } catch (e) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [
                +new Date,
                global,
                plugins,
                global.screen,
                tostring(pool)
            ];
        }
    }
    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
        return String.fromCharCode.apply(0, a);
    }
    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);
    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (0, module.exports) {
        module.exports = seedrandom;
        // When in node.js, try using crypto package for autoseeding.
        try {
            nodecrypto = require("55ffaba5e09143c0");
        } catch (ex) {}
    } else if (typeof define == "function" && define.amd) define(function() {
        return seedrandom;
    });
    else // When included as a plain script, set up Math.seedrandom global.
    math["seed" + rngname] = seedrandom;
// End anonymous scope, and pass initial values.
})(// global: `self` in browsers (including strict mode and web workers),
// otherwise `this` in Node and other environments
typeof self !== "undefined" ? self : this, [], Math // math: package containing random, pow, and seedrandom
);

},{"55ffaba5e09143c0":"jhUEF"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"2NNAu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MoveAction", ()=>MoveAction);
parcelHelpers.export(exports, "MoveCast", ()=>MoveCast);
var _action = require("./action");
class MoveAction extends (0, _action.Action) {
    constructor(owner){
        super("Move", owner);
        this.minLevel = 0;
        this.maxLevel = 0;
        this.isCancelableByUser = true;
        this.isCooldownFinishedOnInterrupt = true;
        this.isUltimate = false;
    }
    get castTime() {
        return this.owner.sim.tickTime;
    }
    get cooldownTime() {
        return 0;
    }
    get value() {
        return this.owner.ms * (this.owner.sim.tickTime / 1000);
    }
    cast(option) {
        return new MoveCast(this, option).init();
    }
    awayFrom(unit) {
        if (unit.pos <= this.owner.pos) return this.cast(Infinity);
        else return this.cast(-Infinity);
    }
    closeTo(unit) {
        return this.cast(unit.pos);
    }
}
class MoveCast extends (0, _action.PosCast) {
    async onFinishCast() {
        const dif = this.option - this.action.owner.pos;
        if (dif >= 0) this.action.owner.pos += Math.min(dif, this.action.value);
        else this.action.owner.pos += Math.max(dif, -this.action.value);
    }
}

},{"./action":"InEMf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8r64O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Champion", ()=>Champion);
var _unit = require("../../unit/unit");
class Champion extends (0, _unit.Unit) {
    levelUpAnyChampion(Q, W, E, R) {
        for(let availableLevelUps = this.level; availableLevelUps > 0; availableLevelUps -= 1){
            let first;
            switch(this.levelUpPriority[0]){
                case "Q":
                    first = Q;
                    break;
                case "W":
                    first = W;
                    break;
                case "E":
                    first = E;
                    break;
                default:
                case "R":
                    first = R;
                    break;
            }
            let second;
            switch(this.levelUpPriority[1]){
                case "Q":
                    second = Q;
                    break;
                case "W":
                    second = W;
                    break;
                case "E":
                    second = E;
                    break;
                default:
                case "R":
                    second = R;
                    break;
            }
            let third;
            switch(this.levelUpPriority[2]){
                case "Q":
                    third = Q;
                    break;
                case "W":
                    third = W;
                    break;
                case "E":
                    third = E;
                    break;
                default:
                case "R":
                    third = R;
                    break;
            }
            let fourth;
            switch(this.levelUpPriority[3]){
                case "Q":
                    fourth = Q;
                    break;
                case "W":
                    fourth = W;
                    break;
                case "E":
                    fourth = E;
                    break;
                default:
                case "R":
                    fourth = R;
                    break;
            }
            if (first.level >= first.minLevel) {
                if (second.minLevel < second.minLevel && second.levelUp()) continue;
                if (second.level >= second.minLevel) {
                    if (third.minLevel < third.minLevel && third.levelUp()) continue;
                    if (third.level >= third.minLevel) {
                        if (fourth.level < fourth.minLevel && fourth.levelUp()) continue;
                    }
                }
            }
            if (!first.levelUp()) {
                if (!second.levelUp()) {
                    if (!third.levelUp()) fourth.levelUp();
                }
            }
        }
    }
    calcStatGrowth(growth) {
        return growth * (this.level - 1) * (0.7025 + 0.0175 * (this.level - 1));
    }
    init(simIN) {
        super.init(simIN);
        this.maxHealth = this.stats.baseHealth + this.calcStatGrowth(this.stats.healthGrowth);
        this.health = this.maxHealth;
        this.baseAd = this.stats.baseAd;
        this.bonusAd = this.calcStatGrowth(this.stats.adGrowth);
        this.attackRange = this.stats.attackRange;
        this.armor = this.stats.baseArmor + this.calcStatGrowth(this.stats.armorGrowth);
        this.attackAnimation = this.stats.attackAnimation;
        this.baseAs = this.stats.baseAs;
        this.bonusAs.value = this.calcStatGrowth(this.stats.asGrowth);
        this.baseMs = this.stats.baseMs;
        this.mana = this.stats.baseMana + this.calcStatGrowth(this.stats.manaGrowth);
        this.maxMana = this.mana;
        return this;
    }
}

},{"../../unit/unit":"hwZ7t","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kRNkn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiStats", ()=>MasterYiStats);
const MasterYiStats = {
    baseMs: 355,
    baseAs: 0.679,
    asGrowth: 2,
    baseHealth: 669,
    healthGrowth: 100,
    baseMana: 251,
    manaGrowth: 42,
    attackAnimation: 0.24375,
    attackRange: 175,
    baseAd: 65,
    adGrowth: 2.2,
    baseArmor: 33,
    armorGrowth: 4.2
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"RltaG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiEBuff", ()=>MasterYiEBuff);
parcelHelpers.export(exports, "MasterYiECast", ()=>MasterYiECast);
parcelHelpers.export(exports, "MasterYiE", ()=>MasterYiE);
var _action = require("../../unit/action/action");
var _buff = require("../../unit/buff");
var _unitInteraction = require("../../unit/unitInteraction");
class MasterYiEBuff extends (0, _buff.TimedBuff) {
    constructor(unit, level){
        level = Math.max(0, Math.min(5, level));
        super(MasterYiE.ename, unit, level ? 5000 : 0);
        this.level = level;
        if (!level) return;
        this.removeOnHit = unit.action.attack.onHitUnit((target, m)=>{
            target.interaction.takeDamage({
                value: MasterYiE.damage(unit, level) * m,
                src: unit,
                type: (0, _unitInteraction.DamageType).TRUE
            });
        });
    }
    fade() {
        super.fade();
        this.removeOnHit?.();
    }
}
class MasterYiECast extends (0, _action.SelfCast) {
    async onFinishCast() {
        new MasterYiEBuff(this.action.owner, this.action.level);
    }
}
class MasterYiE extends (0, _action.Action) {
    constructor(unit){
        super(MasterYiE.ename, unit);
        this.maxLevel = 5;
        this.minLevel = 1;
        this.isCancelableByUser = false;
        this.isCooldownFinishedOnInterrupt = false;
        this.isUltimate = false;
    }
    static{
        this.ename = "Wuju Style";
    }
    get castTime() {
        return 0;
    }
    get cooldownTime() {
        if (this.level === 0) return 0;
        return 14000;
    }
    static damage(src, level) {
        if (level <= 0) return 0;
        return 25 + level * 5 + src.bonusAd * 0.3;
    }
    async cast() {
        return new MasterYiECast(this).init();
    }
}

},{"../../unit/action/action":"InEMf","../../unit/buff":"alJuQ","../../unit/unitInteraction":"ipKmh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alJuQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Buff", ()=>Buff);
parcelHelpers.export(exports, "TimedBuff", ()=>TimedBuff);
parcelHelpers.export(exports, "TimedSlow", ()=>TimedSlow);
class Buff {
    constructor(name, owner, unique = false, src = owner){
        this.name = name;
        this.owner = owner;
        this.unique = unique;
        this.src = src;
        this.slow = 0;
        if (unique && owner.buffNamed(name)) throw new Error(`Buff ${name} is unique`);
        owner.buffs.push(this);
    }
    get remainingTime() {
        return Infinity;
    }
    set remainingTime(remainingTime) {}
    get duration() {
        return Infinity;
    }
    set duration(value) {}
    get isActive() {
        return this.owner.buffs.includes(this);
    }
    fade() {
        const i = this.owner.buffs.indexOf(this);
        if (i !== -1) this.owner.buffs.splice(i, 1);
    }
}
class TimedBuff extends Buff {
    constructor(name, owner, timeToFade, unique = false, src = owner){
        super(name, owner, unique, src);
        this.promise = owner.sim.waitFor(timeToFade);
        this.promise.then(()=>this.fade());
    }
    get remainingTime() {
        return this.promise.remainingTime;
    }
    set remainingTime(remainingTime) {
        this.promise.remainingTime = remainingTime;
    }
    get duration() {
        return this.promise.waitFor;
    }
    set duration(value) {
        this.promise.waitFor = value;
    }
    fade() {
        this.promise.resolve(true);
        super.fade();
    }
}
class TimedSlow extends TimedBuff {
    constructor(name, owner, timeToFade, src, slow){
        super(name, owner, timeToFade, true, src);
        this.slow = slow;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XjdV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiRBuff", ()=>MasterYiRBuff);
parcelHelpers.export(exports, "MasterYiRCast", ()=>MasterYiRCast);
parcelHelpers.export(exports, "MasterYiR", ()=>MasterYiR);
var _buff = require("../../unit/buff");
var _action = require("../../unit/action/action");
class MasterYiRBuff extends (0, _buff.TimedBuff) {
    constructor(unit, level){
        level = Math.max(0, Math.min(3, level));
        super(MasterYiR.rname, unit, level ? 7000 : 0);
        this.level = level;
        if (!level) return;
        this.removeTakedown = unit.interaction.onTakedown((enemy, damagedTime)=>{
            if (damagedTime + 10000 >= unit.sim.time) this.duration += 7000;
        });
        unit.bonusAs.value += 15 + level * 10;
    }
    fade() {
        super.fade();
        this.removeTakedown?.();
        this.owner.bonusAs.value -= 15 + this.level * 10;
    }
}
class MasterYiRCast extends (0, _action.SelfCast) {
    async onFinishCast() {
        new MasterYiRBuff(this.action.owner, this.action.level);
    }
}
class MasterYiR extends (0, _action.Action) {
    constructor(unit){
        super(MasterYiR.rname, unit);
        this.maxLevel = 3;
        this.minLevel = 1;
        this.isCancelableByUser = false;
        this.isCooldownFinishedOnInterrupt = false;
        this.isUltimate = true;
    }
    static{
        this.rname = "Highlander";
    }
    get manaCost() {
        if (this.level <= 0) return 0;
        return 100;
    }
    get castTime() {
        return 0;
    }
    get cooldownTime() {
        if (this.level === 0) return 0;
        return 85000;
    }
    async cast() {
        return await new MasterYiRCast(this).init();
    }
}

},{"../../unit/buff":"alJuQ","../../unit/action/action":"InEMf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PlHv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiWCast", ()=>MasterYiWCast);
parcelHelpers.export(exports, "MasterYiW", ()=>MasterYiW);
var _action = require("../../unit/action/action");
var _unitInteraction = require("../../unit/unitInteraction");
class MasterYiWCast extends (0, _action.SelfCast) {
    async onStartCast() {
        this.action.owner.action.attack.finishCooldown();
        const cancelDR = this.action.owner.interaction.percentDamageReduction((e)=>{
            if (e.type === (0, _unitInteraction.DamageType).TRUE) return;
            else if (time < 500) e.value *= 0.1;
            else e.value *= (100 - MasterYiW.dr(this.action.level)) / 100;
        });
        let time = 0;
        for(; time <= this.action.castTime; time += 500){
            const result = await Promise.any([
                this.wait(),
                this.action.owner.sim.waitFor(500)
            ]);
            if (result) {
                this.action.owner.interaction.takeHeal({
                    src: this.action.owner,
                    value: MasterYiW.tickHeal(this.action.level, this.action.owner)
                });
                if (this.action.owner.mana >= this.action.channelManaCost) this.action.owner.mana -= this.action.channelManaCost;
                else {
                    this.interrupt();
                    break;
                }
            } else break;
        }
        cancelDR();
    }
}
class MasterYiW extends (0, _action.Action) {
    constructor(unit){
        super(MasterYiW.wname, unit);
        this.maxLevel = 5;
        this.minLevel = 1;
        this.isCancelableByUser = true;
        this.isCooldownFinishedOnInterrupt = false;
        this.isUltimate = true;
    }
    static{
        this.wname = "Meditate";
    }
    get manaCost() {
        if (this.level <= 0) return 0;
        return 40;
    }
    get channelManaCost() {
        if (this.level === 0) return 0;
        return this.owner.maxMana * 0.06;
    }
    get castTime() {
        if (this.level === 0) return 0;
        return 4000;
    }
    get cooldownTime() {
        if (this.level === 0) return 0;
        return 9000;
    }
    static dr(level) {
        if (level <= 0) return 0;
        return 42.5 + level * 2.5;
    }
    static tickHeal(level, owner) {
        if (level <= 0) return 0;
        return (5 + level * 10) * (2 - owner.health / owner.maxHealth);
    }
    async cast() {
        return await new MasterYiWCast(this).init();
    }
}

},{"../../unit/action/action":"InEMf","../../unit/unitInteraction":"ipKmh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8SIbV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiQMark", ()=>MasterYiQMark);
parcelHelpers.export(exports, "MasterYiQCast", ()=>MasterYiQCast);
parcelHelpers.export(exports, "MasterYiQ", ()=>MasterYiQ);
var _seedrandom = require("seedrandom");
var _seedrandomDefault = parcelHelpers.interopDefault(_seedrandom);
var _action = require("../../unit/action/action");
var _buff = require("../../unit/buff");
var _unitInteraction = require("../../unit/unitInteraction");
class MasterYiQMark extends (0, _buff.Buff) {
    constructor(owner, src, level, random){
        level = Math.max(0, Math.min(5, level));
        super(MasterYiQ.qname, owner, false, src);
        this.level = level;
        this.random = random;
        this.damage = MasterYiQ.markDamage(this.src, this.level);
        this.critDamage = MasterYiQ.markCritDamage(this.src, this.level);
    }
    fade() {
        if (!this.isActive) return;
        if (this.owner.targetable.value) {
            const isCrit = this.src.crit >= this.random() * 100;
            const damage = isCrit ? this.damage + this.critDamage : this.damage;
            const modifier = this.owner.buffsNamed(MasterYiQ.qname).length > 1 ? 0.25 : 1;
            this.owner.interaction.takeDamage({
                src: this.src,
                type: (0, _unitInteraction.DamageType).PHYSIC,
                value: damage * modifier,
                isCrit
            });
            this.src.action.attack.procOnHitUnit(this.owner, 0.75 * modifier);
        }
        super.fade();
    }
}
class MasterYiQCast extends (0, _action.TargetCast) {
    constructor(action, option, random){
        super(action, option);
        this.random = random;
    }
    async onStartCast() {
        this.action.owner.targetable.value = false;
        const marks = [];
        for(let time = 0; time < MasterYiQ.markTime * 4; time += MasterYiQ.markTime){
            const result = await Promise.any([
                this.wait(),
                this.action.owner.sim.waitFor(MasterYiQ.markTime)
            ]);
            if (result) marks.push(new MasterYiQMark(this.option, this.action.owner, this.action.level, this.random));
            else break;
        }
        // appear near target
        if (this.action.owner.pos <= this.option.pos) this.action.owner.pos = this.option.pos - 75;
        else this.action.owner.pos = this.option.pos + 75;
        // final wait become targetable
        this.action.owner.targetable.value = true;
        // proc wait - when alive
        if (!this.action.owner.dead.value && this.option.targetable.value) await this.action.owner.sim.waitFor(MasterYiQ.markProcTime);
        // proc
        for (const mark of marks)mark.fade();
    }
}
class MasterYiQ extends (0, _action.EnemyTargetAction) {
    constructor(unit){
        super(MasterYiQ.qname, unit);
        this.maxLevel = 5;
        this.minLevel = 1;
        this.isCancelableByUser = false;
        this.isCooldownFinishedOnInterrupt = false;
        this.isUltimate = false;
        this.random = (0, _seedrandomDefault.default)();
        unit.action.attack.onCast(()=>this.remainingCooldown -= 1000);
    }
    static{
        this.qname = "Alpha Strike";
    }
    get maxRange() {
        return 600;
    }
    get manaCost() {
        if (this.level === 0) return 0;
        return 45 + this.level * 5;
    }
    get castTime() {
        if (this.level === 0) return 0;
        return MasterYiQ.markTime * 4 + MasterYiQ.markProcTime + 1;
    }
    get cooldownTime() {
        if (this.level === 0) return 0;
        return 20500 - this.level * 500;
    }
    static markDamage(owner, level) {
        return level * 30 + owner.ad * 0.5;
    }
    static markCritDamage(owner, level) {
        return (10.5 * level + owner.ad * 0.175) * (1 + owner.bonusCritDamage / 100);
    }
    static{
        this.markTime = 231;
    }
    static{
        this.markProcTime = 164;
    }
    async cast(option) {
        return await new MasterYiQCast(this, option, this.random).init();
    }
}

},{"seedrandom":"kcfU7","../../unit/action/action":"InEMf","../../unit/buff":"alJuQ","../../unit/unitInteraction":"ipKmh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aPd16":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterYiPassive", ()=>MasterYiPassive);
parcelHelpers.export(exports, "MasterYiPassiveBuff", ()=>MasterYiPassiveBuff);
var _buff = require("../../unit/buff");
var _unitInteraction = require("../../unit/unitInteraction");
class MasterYiPassive {
    static{
        this.pname = "Double Strike";
    }
    constructor(owner){
        this.owner = owner;
        this.disabled = false;
    }
    init() {
        this.owner.action.attack.onCast((target)=>{
            if (this.disabled) return;
            const buff = this.buff;
            if (buff) {
                buff.stacks += 1;
                buff.remainingTime = 4000;
                if (buff.stacks >= 3) {
                    buff.stacks = 0;
                    target.interaction.takeDamage({
                        value: this.owner.ad * 0.5,
                        src: this.owner,
                        type: (0, _unitInteraction.DamageType).PHYSIC
                    });
                    this.owner.action.attack.procOnHitUnit(target);
                    this.owner.action.attack.procOnCast(target);
                }
            } else new MasterYiPassiveBuff(this.owner);
        });
        return this;
    }
    get buff() {
        return this.owner.buffNamed(MasterYiPassive.pname);
    }
}
class MasterYiPassiveBuff extends (0, _buff.TimedBuff) {
    constructor(unit){
        super(MasterYiPassive.pname, unit, 4000, true);
        this.stacks = 1;
    }
    fade() {
        super.fade();
    }
}

},{"../../unit/buff":"alJuQ","../../unit/unitInteraction":"ipKmh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2c9S9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Nunu", ()=>Nunu);
var _unit = require("../../unit/unit");
var _champion = require("../champion/champion");
var _nunuStats = require("./NunuStats");
class Nunu extends (0, _champion.Champion) {
    constructor(){
        super("Nunu");
        this.isMelee = true;
        this.stats = (0, _nunuStats.NunuStats);
        this.levelUpPriority = [
            "R",
            "Q",
            "E",
            "W"
        ];
    }
    levelUp() {}
    init(simIN) {
        super.init(simIN);
        this.action = new (0, _unit.Actions)(this);
        this.action.init();
        return this;
    }
}

},{"../../unit/unit":"hwZ7t","../champion/champion":"8r64O","./NunuStats":"8wZW4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8wZW4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NunuStats", ()=>NunuStats);
const NunuStats = {
    baseMs: 345,
    baseAs: 0.625,
    asGrowth: 2.25,
    baseHealth: 610,
    healthGrowth: 90,
    baseMana: 280,
    manaGrowth: 42,
    attackAnimation: 0.19359,
    attackRange: 125,
    baseAd: 61,
    adGrowth: 3,
    baseArmor: 29,
    armorGrowth: 4.2
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"loqvP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "simulateBestNextItem", ()=>simulateBestNextItem);
parcelHelpers.export(exports, "simulateBestBoot", ()=>simulateBestBoot);
parcelHelpers.export(exports, "simulateBestNextItems", ()=>simulateBestNextItems);
var _simulateDummy = require("./simulateDummy");
var _items = require("../items/items");
var _boots = require("../items/boots");
const simulateBestNextItem = async (getChampion, dummyRunsAway = false, itemsToLook = (0, _items.items), maxResults = 10)=>{
    const results = [];
    for (const item of itemsToLook){
        const result = await (0, _simulateDummy.simulateDummy)((sim)=>{
            const champ = getChampion(sim);
            if (champ && champ.applyEquip(item)) return champ;
        }, dummyRunsAway);
        if (result) {
            results.push({
                item,
                result
            });
            results.sort((a, b)=>a.result.ttk - b.result.ttk);
            results.splice(maxResults);
        }
    }
    return results;
};
const simulateBestBoot = async (getChampion, dummyRunsAway = false, itemsToLook = (0, _items.items), maxResults = 10)=>{
    return (await simulateBestNextItem(getChampion, dummyRunsAway, itemsToLook.filter((item)=>item.uniqueGroup === (0, _boots.bootSymbol) && item.type === "finishedItem"), maxResults))[0];
};
const simulateBestNextItems = async (getChampion, count, dummyRunsAway = false, itemsToLook = (0, _items.items), maxResults = 10)=>{
    const result = [];
    for (const preresult of (await simulateBestNextItem(getChampion, dummyRunsAway, itemsToLook, maxResults)))if (count > 1) {
        const nextresults = await simulateBestNextItems((sim)=>{
            const champ = getChampion(sim);
            if (champ && champ.applyEquip(preresult.item)) return champ;
        }, count - 1, dummyRunsAway, itemsToLook, maxResults);
        if (nextresults.length === 0) result.push({
            items: [
                preresult.item
            ],
            result: preresult.result
        });
        else for (const nextresult of nextresults)result.push({
            items: [
                preresult.item,
                ...nextresult.items
            ],
            result: nextresult.result
        });
    } else result.push({
        items: [
            preresult.item
        ],
        result: preresult.result
    });
    for(let subresult1 = 0; subresult1 < result.length; subresult1 += 1)for(let subresult2 = 0; subresult2 < result.length; subresult2 += 1){
        if (subresult1 === subresult2 || result[subresult1].items.length !== result[subresult2].items.length) continue;
        const subresult1sorted = result[subresult1].items.concat().sort((a, b)=>a.name.localeCompare(b.name));
        const subresult2sorted = result[subresult2].items.concat().sort((a, b)=>a.name.localeCompare(b.name));
        let same = true;
        for(const i in result[subresult1].items)if (subresult1sorted[i] !== subresult2sorted[i]) {
            same = false;
            break;
        }
        if (same) {
            result.splice(subresult2, 1);
            subresult2 = Math.max(0, subresult2 - 1);
        }
    }
    result.sort((a, b)=>a.result.ttk - b.result.ttk).splice(maxResults);
    return result;
};

},{"./simulateDummy":"1oP9K","../items/items":"18gB3","../items/boots":"aW4iJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1oP9K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "simulateDummy", ()=>simulateDummy);
var _nunu = require("../champions/Nunu/Nunu");
var _boots = require("../items/boots");
var _simulation = require("./simulation");
const simulateDummy = (getChampion, dummyRunsAway = false, maxTime = 180000)=>{
    return (0, _simulation.simulate1v1)((sim)=>{
        const champion = getChampion(sim);
        if (!champion) return;
        const championLogic = (champion, nunu)=>champion.killDummy(nunu);
        const nunu = new (0, _nunu.Nunu)();
        if (champion.appliedEquips.some((e)=>e.uniqueGroup === (0, _boots.bootSymbol))) nunu.applyEquip((0, _boots.boot));
        nunu.level = champion.level;
        nunu.init(sim);
        const nunuLogic = (nunu, champion)=>{
            if (dummyRunsAway) return nunu.runAwayFromEnemyAsDummy(champion);
        };
        return [
            champion,
            championLogic,
            nunu,
            nunuLogic
        ];
    }, maxTime);
};

},{"../champions/Nunu/Nunu":"2c9S9","../items/boots":"aW4iJ","./simulation":"aBaQe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aW4iJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bootSymbol", ()=>bootSymbol);
parcelHelpers.export(exports, "boot", ()=>boot);
parcelHelpers.export(exports, "berserkers", ()=>berserkers);
parcelHelpers.export(exports, "boots", ()=>boots);
const bootSymbol = Symbol("boots");
const boot = {
    unique: true,
    type: "item",
    name: "Boots",
    bonusMs: 25,
    uniqueGroup: bootSymbol
};
const berserkers = {
    unique: true,
    type: "finishedItem",
    name: "Berserker's Greaves",
    bonusMs: 45,
    bonusAs: 35,
    uniqueGroup: bootSymbol
};
const boots = [
    boot,
    berserkers
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBaQe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Simulation", ()=>Simulation);
parcelHelpers.export(exports, "simulate1v1", ()=>simulate1v1);
var _defered = require("./defered");
if (typeof window != "undefined") require("a87ed7a98c437656");
class Simulation {
    get time() {
        return this._time;
    }
    insertIntoWheel(wheelItem) {
        let start = 0, end = this.wheel.length - 1;
        while(start <= end){
            const mid = start + end >> 1;
            if (this.wheel[mid].time > wheelItem.time) start = mid + 1;
            else end = mid - 1;
        }
        this.wheel.splice(start, 0, wheelItem);
    }
    reinsertIntoWheel(wheelItem, oldWaitFor) {
        let start = 0, end = this.wheel.length - 1;
        while(start <= end){
            const mid = start + end >> 1;
            if (this.wheel[mid] === wheelItem) break;
            else if (this.wheel[mid].time > oldWaitFor) start = mid + 1;
            else end = mid - 1;
        }
        if (this.wheel[start] === wheelItem) {
            this.wheel.splice(start, 1);
            this.insertIntoWheel(wheelItem);
        }
    }
    waitFor(time) {
        const wheelItem = new (0, _defered.WheelItem)(undefined, this, time, (oldWaitFor)=>this.reinsertIntoWheel(wheelItem, oldWaitFor));
        this.insertIntoWheel(wheelItem);
        return wheelItem;
    }
    waitForResolve() {
        return this.waitFor(0);
    }
    get isStopped() {
        return this._isStopped;
    }
    stop() {
        this._isStopped = true;
        for (const wheelItem of this.wheel)wheelItem.resolve(false);
    }
    consume() {
        setImmediate(()=>{
            const next = this.wheel.pop();
            this._time = next.time;
            next.resolve(true);
            if (!this.isStopped && this.wheel.length) this.consume();
        });
    }
    start(maxTime) {
        this.waitFor(maxTime).then(()=>{
            this.stop();
        });
        this.consume();
        return this;
    }
    constructor(){
        this.tickTime = 33;
        this._time = 0;
        this.wheel = [];
        this._isStopped = false;
        this.units = [];
    }
}
const simulate1v1 = async (getChampionsAndLogic, maxTime = 180000)=>{
    const sim = new Simulation();
    const get = getChampionsAndLogic(sim);
    if (!get) return;
    const [champ1, logic1, champ2, logic2] = get;
    sim.start(maxTime);
    // count damage
    let damage1 = 0, damage2 = 0;
    champ2.interaction.onTakeDamage((e)=>damage1 += e.value);
    champ1.interaction.onTakeDamage((e)=>damage2 += e.value);
    // logic
    const champ1Logic = async ()=>{
        while(!champ1.dead.value && !champ2.dead.value && !sim.isStopped){
            const time = sim.time;
            await logic1(champ1, champ2);
            if (sim.time === time) await sim.waitFor(sim.tickTime * 2);
        }
    };
    const champ2Logic = async ()=>{
        while(!champ1.dead.value && !champ2.dead.value && !sim.isStopped){
            const time = sim.time;
            await logic2(champ2, champ1);
            if (sim.time === time) await sim.waitFor(sim.tickTime * 2);
        }
    };
    // sim
    await Promise.all([
        champ1Logic(),
        champ2Logic()
    ]);
    // winner
    const winner = !champ1.dead.value && champ2.dead.value ? champ1 : champ1.dead.value && !champ2.dead.value ? champ2 : undefined;
    // stats
    return {
        ttk: sim.time,
        dps1: damage1 / (sim.time / 1000),
        dps2: damage2 / (sim.time / 1000),
        distance: Math.abs(champ1.pos - champ2.pos),
        winner,
        champion1: champ1,
        champion2: champ2
    };
};

},{"./defered":"fMKmc","a87ed7a98c437656":"g4k8b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fMKmc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Rejection", ()=>Rejection);
parcelHelpers.export(exports, "Defered", ()=>Defered);
parcelHelpers.export(exports, "WheelItem", ()=>WheelItem);
var Rejection;
(function(Rejection) {
    Rejection[Rejection["SimulationStopped"] = 0] = "SimulationStopped";
    Rejection[Rejection["UnitDeath"] = 1] = "UnitDeath";
    Rejection[Rejection["RemoveEventListener"] = 2] = "RemoveEventListener";
    Rejection[Rejection["Canceled"] = 3] = "Canceled";
    Rejection[Rejection["TargetDeath"] = 4] = "TargetDeath";
})(Rejection || (Rejection = {}));
class Defered extends Promise {
    constructor(internal = (i1, i2)=>{
        return undefined;
    }){
        let resolve;
        super((resolveIn, rejectIn)=>{
            resolve = resolveIn;
            return internal(resolveIn, rejectIn);
        });
        this._resolve = resolve;
    }
    get result() {
        return this._result;
    }
    resolve(value) {
        this._result = value;
        this._resolve(value);
    }
}
class WheelItem extends Defered {
    constructor(internal = (i1, i2)=>{
        return undefined;
    }, _sim, _waitFor, _reinsert){
        super((resolveIn, rejectIn)=>{
            return internal(resolveIn, rejectIn);
        });
        this._sim = _sim;
        this._waitFor = _waitFor;
        this._reinsert = _reinsert;
        if (_sim === undefined) return;
        this.timeStart = _sim.time;
    }
    get time() {
        return this.timeStart + this._waitFor;
    }
    get remainingTime() {
        return Math.max(0, this.time - this._sim.time);
    }
    set remainingTime(remainingTime) {
        this.waitFor += remainingTime - this.remainingTime;
    }
    get waitFor() {
        return this._waitFor;
    }
    set waitFor(waitFor) {
        const oldWaitFor = this._waitFor;
        this._waitFor = waitFor;
        this._reinsert(oldWaitFor);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g4k8b":[function(require,module,exports) {
var process = require("96b87729426a727d");
var global = arguments[3];
(function(global, undefined) {
    "use strict";
    if (global.setImmediate) return;
    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;
    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") callback = new Function("" + callback);
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i + 1];
        // Store and register the task
        var task = {
            callback: callback,
            args: args
        };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }
    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }
    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch(args.length){
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }
    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
        // "too much recursion" error.
        setTimeout(runIfPresent, 0, handle);
        else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally{
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function() {
                runIfPresent(handle);
            });
        };
    }
    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }
    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) runIfPresent(+event.data.slice(messagePrefix.length));
        };
        if (global.addEventListener) global.addEventListener("message", onGlobalMessage, false);
        else global.attachEvent("onmessage", onGlobalMessage);
        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };
        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }
    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }
    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }
    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
    // Don't get fooled by e.g. browserify environments.
    if (({}).toString.call(global.process) === "[object process]") // For Node.js before 0.9
    installNextTickImplementation();
    else if (canUsePostMessage()) // For non-IE10 modern browsers
    installPostMessageImplementation();
    else if (global.MessageChannel) // For web workers, where supported
    installMessageChannelImplementation();
    else if (doc && "onreadystatechange" in doc.createElement("script")) // For IE 68
    installReadyStateChangeImplementation();
    else // For older browsers
    installSetTimeoutImplementation();
    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);

},{"96b87729426a727d":"50f2S"}],"18gB3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "items", ()=>items);
var _boots = require("./boots");
var _onHitItems = require("./onHitItems");
const items = [
    ...(0, _boots.boots),
    ...(0, _onHitItems.onHitItems)
];

},{"./boots":"aW4iJ","./onHitItems":"6uXQ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6uXQ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "botrkDamage", ()=>botrkDamage);
parcelHelpers.export(exports, "botrk", ()=>botrk);
parcelHelpers.export(exports, "witsendDamage", ()=>witsendDamage);
parcelHelpers.export(exports, "witsend", ()=>witsend);
parcelHelpers.export(exports, "guinso", ()=>guinso);
parcelHelpers.export(exports, "onHitItems", ()=>onHitItems);
var _masterYi = require("../champions/MasterYi/MasterYi");
var _simulation = require("../simulation/simulation");
var _buff = require("../unit/buff");
var _unitInteraction = require("../unit/unitInteraction");
const botrkDamage = (src, target)=>{
    return src.isMelee ? 0.12 * target.health : 0.09 * target.health;
};
const botrk = {
    unique: true,
    type: "finishedItem",
    name: "Blade of the Ruined King",
    bonusAd: 40,
    bonusAs: 25,
    lifesteal: 8,
    apply: (unit)=>{
        let lastActivation = -Infinity;
        unit.action.attack.onHitUnit((t, m)=>{
            const result = t.interaction.takeDamage({
                src: unit,
                type: (0, _unitInteraction.DamageType).PHYSIC,
                value: botrkDamage(unit, t) * m
            }).value;
            if (unit.lifesteal > 0) unit.interaction.takeHeal({
                value: result * (unit.lifesteal / 100),
                src: unit
            });
            if (lastActivation + 15000 <= unit.sim.time) {
                lastActivation = unit.sim.time;
                new (0, _buff.TimedSlow)(botrk.name, t, 1000, unit, 30);
            }
        });
    },
    test: ()=>{
        test("botrk", async ()=>{
            const sim = new (0, _simulation.Simulation)().start(500000);
            const yi1 = new (0, _masterYi.MasterYi)().init(sim);
            const yi2 = new (0, _masterYi.MasterYi)().init(sim);
            yi2.armor = 0;
            yi2.health = 1000;
            expect(yi1.applyEquip(botrk)).toBe(true);
            let botrkhits = 0;
            yi2.interaction.onTakeDamage((e)=>{
                if (e.src === yi1 && e.type === (0, _unitInteraction.DamageType).PHYSIC && e.value === 120) botrkhits += 1;
            });
            expect(await yi1.action.attack.cast(yi2)).toBe(true);
            expect(botrkhits).toBe(1);
            expect(yi2.slow).toBe(30);
            expect(yi2.ms).toBeLessThan(300);
            await sim.waitFor(1001);
            expect(yi2.slow).toBe(0);
            expect(yi2.ms).toBeGreaterThan(300);
            expect(await yi1.action.attack.cast(yi2)).toBe(true);
            expect(yi2.slow).toBe(0);
            expect(yi2.ms).toBeGreaterThan(300);
            await sim.waitFor(13999 - yi1.action.attack.castTime * 2);
            expect(await yi1.action.attack.cast(yi2)).toBe(true);
            expect(yi2.slow).toBe(30);
            expect(yi2.ms).toBeLessThan(300);
        });
    }
};
const witsendDamage = (src)=>{
    let damage = 15;
    if (src.level >= 9) for(let level = 9; level <= Math.min(14, src.level); level += 1)damage += 10;
    if (src.level >= 15) for(let level = 15; level <= Math.min(18, src.level); level += 1)damage += 1.25;
    return damage;
};
const witsend = {
    unique: true,
    type: "finishedItem",
    name: "Wit's End",
    bonusAs: 55,
    mr: 50,
    // TODO: implement & add tenacity
    apply: (unit)=>{
        unit.action.attack.onHitUnit((t, m)=>{
            t.interaction.takeDamage({
                src: unit,
                type: (0, _unitInteraction.DamageType).MAGIC,
                value: witsendDamage(unit) * m
            });
        });
    },
    test: ()=>{
        test("Witsend", async ()=>{
            const sim = new (0, _simulation.Simulation)().start(500000);
            const yi1 = new (0, _masterYi.MasterYi)().init(sim);
            expect(yi1.applyEquip(witsend)).toBe(true);
            const yi2 = new (0, _masterYi.MasterYi)().init(sim);
            expect(witsendDamage(yi1)).toBe(15);
            yi1.level = 6;
            expect(witsendDamage(yi1)).toBe(15);
            yi1.level = 12;
            expect(witsendDamage(yi1)).toBe(55);
            yi1.level = 17;
            expect(witsendDamage(yi1)).toBe(78.75);
            let magic = 0;
            yi2.interaction.onTakeDamage((e)=>{
                if (e.src === yi1 && e.type === (0, _unitInteraction.DamageType).MAGIC && e.value >= 50) magic += 1;
            });
            expect(await yi1.action.attack.cast(yi2)).toBe(true);
            expect(magic).toBe(1);
        });
    }
};
const guinso = {
    name: "Guinsoo's Rageblade",
    unique: true,
    type: "finishedItem",
    bonusAd: 30,
    bonusAs: 25,
    // TODO: AP
    apply: (unit)=>{
        unit.action.attack.onHitUnit((t, m)=>{
            t.interaction.takeDamage({
                src: unit,
                type: (0, _unitInteraction.DamageType).MAGIC,
                value: 30 * m
            });
        });
    },
    test: ()=>{
        test("guinso basic", async ()=>{
            const sim = new (0, _simulation.Simulation)().start(500000);
            const yi1 = new (0, _masterYi.MasterYi)().init(sim);
            expect(yi1.applyEquip(guinso)).toBe(true);
            const yi2 = new (0, _masterYi.MasterYi)().init(sim);
            yi2.mr = 0;
            let magic = 0;
            yi2.interaction.onTakeDamage((e)=>{
                if (e.src === yi1 && e.type === (0, _unitInteraction.DamageType).MAGIC && e.value == 30) magic += 1;
            });
            expect(await yi1.action.attack.cast(yi2)).toBe(true);
            expect(magic).toBe(1);
        });
    }
};
const onHitItems = [
    botrk,
    witsend,
    guinso
];

},{"../champions/MasterYi/MasterYi":"4UhOt","../simulation/simulation":"aBaQe","../unit/buff":"alJuQ","../unit/unitInteraction":"ipKmh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["5keNS","fvuCG"], "fvuCG", "parcelRequireab82")

</script>
  </head>
  <body>
  </body>
</html>